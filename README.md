# Prog366
Prog 366 Columbia College Chicago FA 2020 


# Week 1 Progress
This week I learned about algorithm Specification, including pre and post conditions. I also learned about Reduction, in which we abstract larger problems into smaller components to optimize runtime and stack memory usage in our algorithms. Additionally, I was introduced to Big O Notation, which expresses runtime growth as a function of the size of the input data set. I also learned Big O Notation for several common orders of growth, these include, O(1) or Constant growth, O(n) or Linear growth, and O(n^2) or Quadratic growth.

# Week 4 Progress.
This week's content was focused on introducing numerical algorithms which are algorithms that calculate numbers. First I refamiliarized myself on the modulo operation, which calculates the remander after dividing two numbers. I also learned about different ways to calculate the greatest common divisor. The first of these is to compare the factors of each number to determine the largest shared one. Another is to compute the prime factorization of each number, and find the product of all primes shared by each factorization. The last method of finding GCD that I learned uses the Euclidean Algortithm. The Euclidean Algorithm breaks down the problem into smaller parts. For example to find the GCD of 4, 8, and 6, find the GCD of 4 and 8, which is 4, and then find the GDC of 4 and 6, which is 2. Next, this weeks lessons focused on randomness and random numbers. The generation of random numbers can be broken down into two categories, Psudo-Random Number Generators and True Random Number Generators. Psudo-Random Number Generators, or PRNGs use mathematical formulae or precalulated tables to generates sets that appear random. Though efficient, these are not actually random, as the values are deterministically generated prior to the algorithms execution. Also of note is that the sequence of values generated from PRNGs are often periodic in nature. True Random Number Generators or TRNGs on the other hand uses measurments of randomness found in the physical world. Several examples of such randomness includes radioactive decay, atmospheric noise and transient voltage levels within a machine. TRNGs are both nondeterministic and aperiodic. The last thing I learned this week were several different implementations of the Fisher-Yates Shuffle algorithm. The Fisher-Yates Shuffle generates random permutations of an input data set.
